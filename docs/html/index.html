<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.16"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>DBus Mockery: DBus Mockery</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">DBus Mockery
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.16 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
var searchBox = new SearchBox("searchBox", "search",false,'Search');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */</script>
<div id="main-nav"></div>
</div><!-- top -->
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div class="PageDoc"><div class="header">
  <div class="headertitle">
<div class="title">DBus Mockery </div>  </div>
</div><!--header-->
<div class="contents">
<div class="textblock"><h1><a class="anchor" id="autotoc_md1"></a>
Table of Contents</h1>
<ul>
<li><a href="#Summary">Summary</a></li>
<li><a href="#Documentation">Documentation</a></li>
<li><a href="#Roadmap">Roadmap</a></li>
<li><a href="#Build">Build</a></li>
<li><a href="#Tutorial">Tutorial</a></li>
<li><a href="#Examples">Examples</a></li>
</ul>
<h1><a class="anchor" id="autotoc_md2"></a>
Summary</h1>
<p>The DBus Mockery library wants to make interfacing with a DBus Service / Interface almost as simple as defining a C++ interface. The DBus protocol is almost entirely hidden from the user. This library only enables interfacing with existant DBus APIs. Creating one yourself with this library is currently not planned.</p>
<p>Example interfaces / Predefined interfaces can be found in my repository [dbus-mockery-system]("https://github.com/5cript/dbus-mockery-system").</p>
<h1><a class="anchor" id="autotoc_md3"></a>
Documentation</h1>
<p>!! Todo here, will be doxygen generated and served with github.</p>
<h1><a class="anchor" id="autotoc_md4"></a>
Roadmap</h1>
<p>Here is a checkbox list of all the tings to come and all that are done so far.</p>
<ul>
<li>[x] A bus object for all necessary bus related tasks.<ul>
<li>[x] Handle the bus lifetime</li>
<li>[x] Calling methods</li>
<li>[x] Reading properties</li>
<li>[x] Writing properties</li>
<li>[x] Listening for signals</li>
<li>[x] Starting an event loop</li>
</ul>
</li>
<li>[x] A Macro for declaring DBus interfaces as C++ interfaces.</li>
<li>[x] Attaching or creating a (simple) event loop to the bus object. (Note: If you use the sd_event* object system, you still have to setup and teardown the event stuff yourself, this is not wrapped by this library.)</li>
<li>[x] A rudamentary generator for interfaces. Not really necessary, since writing a simple class declaration is easy and fast, but can be used to get a quick start for big interfaces.</li>
</ul>
<p>On a created interface, linked to a given DBus interface, you can:</p><ul>
<li>[x] Call methods.</li>
<li>[x] Read and Write Properties.</li>
<li>[x] Connect to slots and listen for signals.</li>
<li>[x] Call methods and get the results asnchronously.</li>
<li>[x] Read and Write Properties asynchronously.</li>
</ul>
<h4><a class="anchor" id="autotoc_md5"></a>
Improvements not planed, but sensible:</h4>
<ul>
<li>[ ] Wrap sd_event in another library and make it interact with this.</li>
</ul>
<h1><a class="anchor" id="autotoc_md6"></a>
Build</h1>
<p>This project uses cmake.</p><ul>
<li>cd dbus-mockery</li>
<li>mkdir -p build</li>
<li>cmake ..</li>
<li>make -j4 (or more/less cores)</li>
<li>make install (if you want) </li>
</ul>
<h4><a class="anchor" id="autotoc_md7"></a>
Dependencies:</h4>
<ul>
<li>libsystemd, because the systemd sd-bus library is used underneath.</li>
<li>boost preprocessor</li>
</ul>
<h1><a class="anchor" id="autotoc_md8"></a>
Tutorial</h1>
<p>This is a short tutorial for using the library.</p>
<h3><a class="anchor" id="autotoc_md9"></a>
Getting started</h3>
<ol type="1">
<li>clone the library using git clone</li>
<li>create a building directory somewhere and build the library, see the build chapter.</li>
<li>now you can add the "include" directory to your projects search path and link the lib. Alternatively use make install. I personally advocate for a project structure where all git dependecies are parallel in the filesystem to the dependent project.</li>
</ol>
<h3><a class="anchor" id="autotoc_md10"></a>
Hello World</h3>
<p>A very simple program to start off with. First the includes required for basic mocking: </p><div class="fragment"><div class="line"> {C++}</div>
<div class="line">#include &lt;dbus-mockery/dbus_interface.hpp&gt;</div>
</div><!-- fragment --><p>Here we see a very basic interface. You can use d-feet to inspect and try interfaces provided by services, daemons and other programs. </p><div class="fragment"><div class="line"> {C++}</div>
<div class="line">namespace org::freedesktop</div>
<div class="line">{</div>
<div class="line">    // Declare an interface. This one is just reduced to one function, which is enough for this example</div>
<div class="line">    class IDBus</div>
<div class="line">    {</div>
<div class="line">    public:</div>
<div class="line">        // We want to make this function callable</div>
<div class="line">        virtual auto ListNames() -&gt; std::vector &lt;std::string&gt; = 0;</div>
<div class="line"> </div>
<div class="line">        // Silences a warning, but IDBus is never really used polymorphicly.</div>
<div class="line">        virtual ~IDBus() = default;</div>
<div class="line">    };</div>
<div class="line">}</div>
</div><!-- fragment --><p>Mock the interface (i know the term is not really correct, but the idea comes from mocking frameworks). When you dont provide any Methods, Properties or Signals, a special placeholder macro has to be used called "DBUS_MOCK_NO_*" </p><div class="fragment"><div class="line"> {C++}</div>
<div class="line">DBUS_MOCK_NAMESPACE</div>
<div class="line">(</div>
<div class="line">    (org)(freedesktop),</div>
<div class="line">    IDBus,</div>
<div class="line">    DBUS_MOCK_METHODS(ListNames),</div>
<div class="line">    DBUS_MOCK_NO_PROPERTIES,</div>
<div class="line">    DBUS_MOCK_NO_SIGNALS</div>
<div class="line">)</div>
</div><!-- fragment --><p>This shows how to use our set up interface: </p><div class="fragment"><div class="line"> {C++}</div>
<div class="line">int main()</div>
<div class="line">{</div>
<div class="line">    using namespace DBusMock;</div>
<div class="line"> </div>
<div class="line">    // open the system bus</div>
<div class="line">    auto bus = open_system_bus();</div>
<div class="line"> </div>
<div class="line">    // bind the interface to the remote dbus interface:</div>
<div class="line">    auto dbusInterface = create_interface &lt;org::freedesktop::IDBus&gt;(</div>
<div class="line">        bus,</div>
<div class="line">        &quot;org.freedesktop.DBus&quot;,</div>
<div class="line">        &quot;/org/freedesktop/DBus&quot;,</div>
<div class="line">        &quot;org.freedesktop.DBus&quot;</div>
<div class="line">    );</div>
<div class="line"> </div>
<div class="line">    // you can now call list names:</div>
<div class="line">    auto services = dbusInterface.ListNames();</div>
<div class="line"> </div>
<div class="line">    // print all to console, which aren&#39;t stupidly named / numbered, therefore unnamed</div>
<div class="line">    for (auto const&amp; service : services)</div>
<div class="line">        if (service.front() != &#39;:&#39;)</div>
<div class="line">            std::cout &lt;&lt; service &lt;&lt; &quot;\n&quot;;</div>
<div class="line"> </div>
<div class="line">    // -&gt; org.freedesktop.DBus</div>
<div class="line">    //    org.freedesktop.Accounts</div>
<div class="line">    //    org.bluez</div>
<div class="line">    //    ...</div>
<div class="line"> </div>
<div class="line">    return 0;</div>
<div class="line">}</div>
</div><!-- fragment --><h3><a class="anchor" id="autotoc_md11"></a>
Asynchronous calls</h3>
<p>Now lets change a little bit of the program. We now dont want to do the call synchronously, but asynchronously. Note that as soon as an event handling loop is attached to the bus, even the synchronous calls get processed by the loop and block while its not their turn to be executed, which, in bad cases, can result in "long" wait times at these functions, which may be undersirable. I therefore recommend to switch to an entirely asynchronous architecture when you use any asynchronous methods/signals on the bus.</p>
<p>Asynchronous functions use "continuation" style. Which means that when ever an asynchronous function finishes, a callback is called from which on execution can be resumed.</p>
<p>Properties can also be read and written asynchronously, by calling get/set on them with the async flag, just the same as with methods.</p>
<p>Only showing relevant differences to before: </p><div class="fragment"><div class="line"> {C++}</div>
<div class="line">// new required header for the event loop</div>
<div class="line">#include &lt;dbus-mockery/bindings/busy_loop.hpp&gt;</div>
<div class="line"> </div>
<div class="line">int main()</div>
<div class="line">{</div>
<div class="line">    using namespace DBusMock;</div>
<div class="line">    using namespace std::chrono_literals;</div>
<div class="line"> </div>
<div class="line">    // open the system bus</div>
<div class="line">    auto bus = open_system_bus();</div>
<div class="line"> </div>
<div class="line">    // create an event loop and attach it to the bus.</div>
<div class="line">    // This is the default implementation, you can provide your own. For instance by using sd_event.</div>
<div class="line">    make_busy_loop(&amp;bus);</div>
<div class="line"> </div>
<div class="line">    // bind the interface to the remote dbus interface:</div>
<div class="line">    auto dbusInterface = create_interface &lt;org::freedesktop::IDBus&gt;(</div>
<div class="line">        bus,</div>
<div class="line">        &quot;org.freedesktop.DBus&quot;,</div>
<div class="line">        &quot;/org/freedesktop/DBus&quot;,</div>
<div class="line">        &quot;org.freedesktop.DBus&quot;</div>
<div class="line">    );</div>
<div class="line"> </div>
<div class="line">    // call ListNames asynchronously with async_flag overload:</div>
<div class="line">    // (always the first parameter, if there are any)</div>
<div class="line">    dbusInterface.ListNames(async_flag)</div>
<div class="line">        // if you omit the then, you wont get a result / response.</div>
<div class="line">        // Which can be fine, but is usually not intended</div>
<div class="line">        .then([](auto const&amp; services)</div>
<div class="line">        {</div>
<div class="line">            // print all to console, which aren&#39;t stupidly named / numbered, therefore unnamed</div>
<div class="line">            for (auto const&amp; service : services)</div>
<div class="line">                if (service.front() != &#39;:&#39;)</div>
<div class="line">                    std::cout &lt;&lt; service &lt;&lt; &quot;\n&quot;;</div>
<div class="line">        })</div>
<div class="line">        // This is called when something goes wrong</div>
<div class="line">        // Can be omited</div>
<div class="line">        .error([](auto&amp;, auto const&amp; errorMessage)</div>
<div class="line">        {</div>
<div class="line">            // first parameter is the result message,</div>
<div class="line">            // It probably does not contain anything useful.</div>
<div class="line"> </div>
<div class="line">            std::cerr &lt;&lt; errorMessage &lt;&lt; &quot;\n&quot;;</div>
<div class="line">        })</div>
<div class="line">        // A timeout for completion, optional.</div>
<div class="line">        // default is 10 seconds</div>
<div class="line">        .timeout(1s)</div>
<div class="line">    ;</div>
<div class="line"> </div>
<div class="line">    return 0;</div>
<div class="line">}</div>
</div><!-- fragment --><p> Asynchronous calls return a proxy object that can be used to bind callback, error callback and timeout before the call is made. The execution is made when the proxy object gets destroyed, which is after the end of the statement.</p>
<p>So you should ignore the return, and not pass it to a variable, like so: </p><div class="fragment"><div class="line"> {C++}</div>
<div class="line">// DONT!</div>
<div class="line">auto&amp;&amp; temp = dbusInterface.ListNames(async_flag);</div>
</div><!-- fragment --><p> unless you actually want that like so: </p><div class="fragment"><div class="line"> {C++}</div>
<div class="line">{ // artifical scope</div>
<div class="line">    auto&amp;&amp; temp = dbusInterface.ListNames(async_flag);</div>
<div class="line"> </div>
<div class="line">    temp.then([](auto const&amp;){</div>
<div class="line">        std::cout &lt;&lt; &quot;callback!\n&quot;;</div>
<div class="line">    });</div>
<div class="line">} // asynchronous call is made here.</div>
</div><!-- fragment --><h3><a class="anchor" id="autotoc_md12"></a>
Variants</h3>
<p>Variants are containers that can contain a number of types. In order to read out of a variant, you have to know its stored type first. Luckily sdbus can deliver this information. One small note: due to implementation restrictions, loading and storing a value from a variant can only be done by a free function and not by a member function. This would look like follows:</p>
<div class="fragment"><div class="line"> {C++}</div>
<div class="line">// Example for reading a variant.</div>
<div class="line"> </div>
<div class="line">#include &lt;dbus-mockery/dbus_interface.hpp&gt;</div>
<div class="line">#include &lt;dbus-mockery/bindings/variant_helpers.hpp&gt;</div>
<div class="line">#include &lt;iostream&gt;</div>
<div class="line"> </div>
<div class="line">int main()</div>
<div class="line">{</div>
<div class="line">    auto bus = open_system_bus();</div>
<div class="line"> </div>
<div class="line">    // a variant dictionary is a map of variants.</div>
<div class="line">    variant_dictionary&lt;std::map&gt; dict;</div>
<div class="line">    bus.read_properties</div>
<div class="line">    (</div>
<div class="line">        &quot;org.freedesktop.Accounts&quot;,</div>
<div class="line">        &quot;/org/freedesktop/Accounts&quot;,</div>
<div class="line">        &quot;org.freedesktop.Accounts&quot;,</div>
<div class="line">        dict</div>
<div class="line">    );</div>
<div class="line"> </div>
<div class="line">    // In case that you dont know the type beforehand, but have to test first:</div>
<div class="line">    auto descriptor = dict[&quot;DaemonVersion&quot;].type();</div>
<div class="line"> </div>
<div class="line">    // print it in a somewhat readable way.</div>
<div class="line">    std::cout &lt;&lt; descriptor.string() &lt;&lt; &quot;\n&quot;;</div>
<div class="line"> </div>
<div class="line">    std::string ver, ver2;</div>
<div class="line">    variant_load&lt;std::string&gt;(dict[&quot;DaemonVersion&quot;], ver);</div>
<div class="line">    std::cout &lt;&lt; ver &lt;&lt; &quot;\n&quot;;</div>
<div class="line"> </div>
<div class="line">    // You do NOT need to rewind a variant before rereading it, this is done for you.</div>
<div class="line">    // dict[&quot;DaemonVersion&quot;].rewind();</div>
<div class="line">    variant_load&lt;std::string&gt;(dict[&quot;DaemonVersion&quot;], ver2);</div>
<div class="line">    std::cout &lt;&lt; ver2 &lt;&lt; &quot;\n&quot;;</div>
<div class="line">}</div>
</div><!-- fragment --><div class="fragment"><div class="line"> {C++}</div>
<div class="line">// Example for writing to a variant.</div>
<div class="line"> </div>
<div class="line">#include &lt;dbus-mockery/dbus_interface.hpp&gt;</div>
<div class="line">#include &lt;dbus-mockery/bindings/variant_helpers.hpp&gt;</div>
<div class="line">#include &lt;iostream&gt;</div>
<div class="line"> </div>
<div class="line">using namespace std::string_literals;</div>
<div class="line"> </div>
<div class="line">int main()</div>
<div class="line">{</div>
<div class="line">    auto bus = open_system_bus();</div>
<div class="line"> </div>
<div class="line">    variant var;</div>
<div class="line">    // has to be non-member unfortunately</div>
<div class="line">    variant_store(bus, var, &quot;hello&quot;s);</div>
<div class="line"> </div>
<div class="line">    std::string val;</div>
<div class="line">    variant_load(var, val);</div>
<div class="line">    std::cout &lt;&lt; val &lt;&lt; &quot;\n&quot;; // -&gt; hello</div>
<div class="line"> </div>
<div class="line">    std::cout &lt;&lt; std::flush;</div>
<div class="line">    return 0;</div>
<div class="line">}</div>
</div><!-- fragment --><h1><a class="anchor" id="autotoc_md13"></a>
Examples</h1>
<p>More examples are in the example directory </p>
<h2><a class="anchor" id="autotoc_md14"></a>
Introductory example (User Accounts)</h2>
<p>Here is the first example, to show a basis of what this library wants to do. </p><div class="fragment"><div class="line"> {C++}</div>
<div class="line">#include &lt;dbus-mockery/dbus_interface.hpp&gt;</div>
<div class="line"> </div>
<div class="line">#include &lt;iostream&gt;</div>
<div class="line">#include &lt;vector&gt;</div>
<div class="line">#include &lt;string&gt;</div>
<div class="line"> </div>
<div class="line">using namespace DBusMock;</div>
<div class="line"> </div>
<div class="line">/**</div>
<div class="line"> * @brief The IAccounts interface. Its the provided interface (org.freedesktop.Accounts) as a C++ class.</div>
<div class="line"> */</div>
<div class="line">class IAccounts</div>
<div class="line">{</div>
<div class="line">public:</div>
<div class="line">    virtual ~IAccounts() = default;</div>
<div class="line"> </div>
<div class="line">    virtual auto CacheUser(std::string const&amp; name) -&gt; object_path = 0;</div>
<div class="line">    virtual auto CreateUser(std::string const&amp; name, std::string const&amp; fullname, int32_t accountType) -&gt; object_path = 0;</div>
<div class="line">    virtual auto DeleteUser(int64_t id, bool removeFiles) -&gt; void = 0;</div>
<div class="line">    virtual auto FindUserById(int64_t id) -&gt; object_path = 0;</div>
<div class="line">    virtual auto ListCachedUsers() -&gt; std::vector &lt;object_path&gt; = 0;</div>
<div class="line">    virtual auto UncacheUser(std::string const&amp; user) -&gt; void = 0;</div>
<div class="line"> </div>
<div class="line">public: // Properties</div>
<div class="line">    readable &lt;std::vector &lt;object_path&gt;&gt; AutomaticLoginUsers;</div>
<div class="line">    readable &lt;bool&gt; HasMultipleUsers;</div>
<div class="line">    readable &lt;bool&gt; HasNoUsers;</div>
<div class="line">    readable &lt;std::string&gt; DaemonVersion;</div>
<div class="line"> </div>
<div class="line">public: // signals</div>
<div class="line">    using UserAdded = void(object_path);</div>
<div class="line">    using UserDeleted = void(object_path);</div>
<div class="line">};</div>
<div class="line"> </div>
<div class="line">//----------------------------------------------------------------------------------------</div>
<div class="line"> </div>
<div class="line">// This step is necessary to enable interface auto-implementation.</div>
<div class="line">// There is a limit to how many properterties and methods are possible. (currently either 64 or 255 each, haven&#39;t tried, assume 64)</div>
<div class="line">// This limit can be circumvented by DBUS_MOCK_N. Which allows to mock the same interface more than once.</div>
<div class="line">// A successory call to DBUS_MOCK_ZIP merges them all together.</div>
<div class="line">DBUS_MOCK</div>
<div class="line">(</div>
<div class="line">    IAccounts,</div>
<div class="line">    DBUS_MOCK_METHODS(CacheUser, CreateUser, DeleteUser, FindUserById, ListCachedUsers, UncacheUser),</div>
<div class="line">    DBUS_MOCK_PROPERTIES(AutomaticLoginUsers, HasMultipleUsers, HasNoUsers, DaemonVersion),</div>
<div class="line">    DBUS_MOCK_SIGNALS(UserAdded, UserDeleted)</div>
<div class="line">)</div>
<div class="line"> </div>
<div class="line">//----------------------------------------------------------------------------------------</div>
<div class="line"> </div>
<div class="line">int main()</div>
<div class="line">{</div>
<div class="line">    // open the system bus.</div>
<div class="line">    auto bus = open_system_bus();</div>
<div class="line"> </div>
<div class="line">    try</div>
<div class="line">    {</div>
<div class="line">        // attach interface to remote interface.</div>
<div class="line">        auto user_control = create_interface &lt;IAccounts&gt; (bus, &quot;org.freedesktop.Accounts&quot;, &quot;/org/freedesktop/Accounts&quot;, &quot;org.freedesktop.Accounts&quot;);</div>
<div class="line"> </div>
<div class="line">        // calling a method with parameters</div>
<div class="line">        //user_control.CreateUser(&quot;hello&quot;, &quot;hello&quot;, 0);</div>
<div class="line"> </div>
<div class="line">        // calling a method and getting the result</div>
<div class="line">        auto cachedUsers = user_control.ListCachedUsers();</div>
<div class="line"> </div>
<div class="line">        for (auto const&amp; user : cachedUsers)</div>
<div class="line">        {</div>
<div class="line">            // the object_path type has a stream operator for output</div>
<div class="line">            std::cout &lt;&lt; user &lt;&lt; &quot;\n&quot;;</div>
<div class="line">        }</div>
<div class="line"> </div>
<div class="line">        // reading a property</div>
<div class="line">        std::cout &lt;&lt; user_control.DaemonVersion &lt;&lt; &quot;\n&quot;;</div>
<div class="line">    }</div>
<div class="line">    catch (std::exception const&amp; exc) // catch all possible exceptions.</div>
<div class="line">    {</div>
<div class="line">        std::cout &lt;&lt; exc.what() &lt;&lt; &quot;\n&quot;;</div>
<div class="line">    }</div>
<div class="line"> </div>
<div class="line">    return 0;</div>
<div class="line">}</div>
</div><!-- fragment --><h2><a class="anchor" id="autotoc_md15"></a>
Connect signal with slot</h2>
<p>Here is an example on how to listen to emitted signals. Note that signal handling requires an event loop.</p>
<div class="fragment"><div class="line"> {C++}</div>
<div class="line">#include &lt;dbus-mockery/dbus_interface.hpp&gt;</div>
<div class="line">#include &lt;dbus-mockery/bindings/bus.hpp&gt;</div>
<div class="line">#include &lt;dbus-mockery/bindings/busy_loop.hpp&gt;</div>
<div class="line"> </div>
<div class="line">#include &lt;iostream&gt;</div>
<div class="line">#include &lt;string&gt;</div>
<div class="line"> </div>
<div class="line">#include &lt;thread&gt;</div>
<div class="line">#include &lt;chrono&gt;</div>
<div class="line"> </div>
<div class="line">using namespace DBusMock;</div>
<div class="line">using namespace std::chrono_literals;</div>
<div class="line"> </div>
<div class="line">/**</div>
<div class="line"> * @brief The IAccounts interface. Its the provided interface (org.freedesktop.Accounts) as a C++ class.</div>
<div class="line"> */</div>
<div class="line">class IAccounts</div>
<div class="line">{</div>
<div class="line">public:</div>
<div class="line">    virtual ~IAccounts() = default;</div>
<div class="line"> </div>
<div class="line">public: // Methods</div>
<div class="line">    virtual auto CreateUser(std::string const&amp; name, std::string const&amp; fullname, int32_t accountType) -&gt; object_path = 0;</div>
<div class="line">    virtual auto DeleteUser(int64_t id, bool removeFiles) -&gt; void = 0;</div>
<div class="line">public: // Properties</div>
<div class="line">public: // signals</div>
<div class="line">    DBusMock::signal &lt;void(object_path)&gt; UserAdded;</div>
<div class="line">    DBusMock::signal &lt;void(object_path)&gt; UserDeleted;</div>
<div class="line">};</div>
<div class="line"> </div>
<div class="line">//----------------------------------------------------------------------------------------</div>
<div class="line"> </div>
<div class="line">// This step is necessary to enable interface auto-implementation.</div>
<div class="line">// There is a limit to how many properterties and methods are possible. (currently either 64 or 255 each, haven&#39;t tried, assume 64)</div>
<div class="line">// This limit can be circumvented by DBUS_MOCK_N. Which allows to mock the same interface more than once.</div>
<div class="line">// A successory call to DBUS_MOCK_ZIP merges them all together.</div>
<div class="line">DBUS_MOCK</div>
<div class="line">(</div>
<div class="line">    IAccounts,</div>
<div class="line">    DBUS_MOCK_METHODS(CreateUser, DeleteUser),</div>
<div class="line">    DBUS_MOCK_NO_PROPERTIES,</div>
<div class="line">    DBUS_MOCK_SIGNALS(UserAdded, UserDeleted)</div>
<div class="line">)</div>
<div class="line"> </div>
<div class="line">int main()</div>
<div class="line">{</div>
<div class="line">    auto bus = open_system_bus();</div>
<div class="line"> </div>
<div class="line">    try</div>
<div class="line">    {</div>
<div class="line">        bus.install_event_loop(std::unique_ptr &lt;event_loop&gt; (new busy_loop(&amp;bus, 50ms)));</div>
<div class="line"> </div>
<div class="line">        // wrapped interface for creating / deleting accounts.</div>
<div class="line">        auto accountControl = create_interface &lt;IAccounts&gt;(</div>
<div class="line">            bus,</div>
<div class="line">            &quot;org.freedesktop.Accounts&quot;,</div>
<div class="line">            &quot;/org/freedesktop/Accounts&quot;,</div>
<div class="line">            &quot;org.freedesktop.Accounts&quot;</div>
<div class="line">        );</div>
<div class="line"> </div>
<div class="line">        accountControl.UserAdded.listen(</div>
<div class="line">            [](object_path const&amp; p) {</div>
<div class="line">                // success callback</div>
<div class="line">                std::cout &lt;&lt; &quot;callback - create: &quot; &lt;&lt; p &lt;&lt; std::endl;</div>
<div class="line">            },</div>
<div class="line">            [](message&amp;, std::string const&amp; str) {</div>
<div class="line">                // failure callback</div>
<div class="line">                std::cerr &lt;&lt; &quot;oh no something gone wrong: &quot; &lt;&lt; str &lt;&lt; &quot;\n&quot;;</div>
<div class="line">            }</div>
<div class="line">        );</div>
<div class="line"> </div>
<div class="line">        // WARNING! Passing &quot;release_slot&quot; forces you to manage the slots lifetime yourself!</div>
<div class="line">        // You can use this variation to manage lifetimes of your observed signals. With a unique_ptr for example.</div>
<div class="line">        auto* slot = accountControl.UserDeleted.listen(</div>
<div class="line">            [&amp;](object_path const&amp; p) {</div>
<div class="line">                // this is called from the dbus system.</div>
<div class="line">                std::cout &lt;&lt; &quot;callback - delete: &quot; &lt;&lt; p &lt;&lt; std::endl;</div>
<div class="line"> </div>
<div class="line">                // create a user from here.</div>
<div class="line">                auto path = accountControl.CreateUser(&quot;tempus&quot;, &quot;tempus&quot;, 0);</div>
<div class="line">            },</div>
<div class="line">            [](message&amp;, std::string const&amp; str) {</div>
<div class="line">                // this is called when an error got signaled into our callback.</div>
<div class="line">                std::cerr &lt;&lt; &quot;oh no something gone wrong: &quot; &lt;&lt; str &lt;&lt; &quot;\n&quot;;</div>
<div class="line">            },</div>
<div class="line">            DBusMock::release_slot</div>
<div class="line">            );</div>
<div class="line"> </div>
<div class="line">            // try to delete a user with id 1001. WARNING, DONT JUST DELETE SOME USER ON YOUR SYSTEM. obviously...</div>
<div class="line">            try {</div>
<div class="line">                // commented out in case you just run this example</div>
<div class="line">                // you should get the id from the name first.</div>
<div class="line">                //accountControl.DeleteUser(1001, false);</div>
<div class="line">            } catch (std::exception const&amp; exc) {</div>
<div class="line">                // Create the user if he doesn&#39;t exist</div>
<div class="line">                accountControl.CreateUser(&quot;tempus&quot;, &quot;tempus&quot;, 0);</div>
<div class="line">                std::cout &lt;&lt; exc.what() &lt;&lt; std::endl;</div>
<div class="line">            }</div>
<div class="line"> </div>
<div class="line">            // just wait here so we dont exit directly</div>
<div class="line">            std::cin.get();</div>
<div class="line"> </div>
<div class="line">        // cleanup. IF!!! you passed &quot;release_slot&quot;</div>
<div class="line">        delete slot;</div>
<div class="line">    }</div>
<div class="line">    catch (std::exception const&amp; exc)</div>
<div class="line">    {</div>
<div class="line">        std::cout &lt;&lt; exc.what() &lt;&lt; &quot;\n&quot;;</div>
<div class="line">    }</div>
<div class="line"> </div>
<div class="line">    return 0;</div>
<div class="line">}</div>
</div><!-- fragment --> </div></div><!-- PageDoc -->
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.16
</small></address>
</body>
</html>
